> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 네트워크 계층

스위치끼리 연결되어 커진 브로드캐스트 도메인은 많은 트래픽이 발생하기 때문에 어떻게든 브로드캐스트 도메인을 나눠줘야 할 것 같습니다. 여기서 어떤 장치를 만들어 브로드캐스트 도메인을 나눴다고 가정하자. 그러면 우리랑 전혀 상관이 없는 미국에 사는 짱구와 철수가 통신하더라도 우리는 브로드캐스트 메세지가 전달되지 않을 것이다. 그러면 쓸데없는 트래픽이 오지 않을 것이다. 여기서 우리가 짱구와 통신을 하고 싶다면 어떻게 될까? 우리가 보내려는 데이터에 출발지 MAC주소는 우리의 MAC주소, 목적지 MAC주소는 짱구의 MAC주소를 적고 스위치로 전송할 것이다. 하지만 스위치는 자신의 MAC주소 테이블에 해당 메세지의 목적지 MAC주소와 일치하는 주소가 없으므로 Flooding을 한다. 그럼 중간에 블랙박스로 데이터가 전송되지만 블랙박스는 자신에게 온 데이터가 아니므로 버릴 것이다. 이런 상황에서는 우리와 짱구는 영영 통신하지 못한다. 이렇게 LAN영역에서 다른 LAN영역으로 넘어가게 되면 기존에 사용하던 출발지, 목적지 MAC주소만으로는 다른 LAN영역에 있는 컴퓨터에 전송하기 힘들다.

이런 문제가 발생하니 사람들은 물리적인 주소인 MAC주소 외에 논리적인 주소를 추가로 만들어야겠다는 생각을 하게 된다. 그리고 브로드캐스트 도메인을 나누는 어떤 장치에 라우터라는 이름을 붙이고 IP주소를 활용해 LAN영역 사이를 문제없이 통신하도록 만들었다. IP주소 덕분에 다른 네트워크에 있는 컴퓨터를 정확하게 나타낼 수 있고 라우터가 복잡한 네트워크에서 경로를 지정할 수 있다. 이전 상황에서 논리적인 주소인 IP주소를 추가하여 통신하는 모습을 보자. 먼저 우리의 PC와 라우터, 짱구의 PC에는 MAC주소뿐만 아니라 IP주소까지 할당된다. 라우터는 여러개의 포트가 있으므로 포트마다 MAC주소와 IP주소가 할당된다. 우리는 짱구에게 데이터를 전송하기 위해서 출발지 IP주소엔 우리의 IP주소, 목적지 IP주소엔 짱구의 IP주소를 적고 출발지 MAC주소엔 우리의 MAC주소, 목적지 MAC주소엔 짱구의 MAC주소가 아닌 라우터의 MAC주소를 적고 전송한다. 그러면 스위치를 통해 라우터로 전달된다. 라우터는 데이터의 목적지 MAC주소를 보고 자신에게 온 데이터인걸 확인하고 목적지 IP를 확인한다. 그리고 받은 메세지에서 IP주소는 바꾸지 않고 출발지 MAC주소는 라우터의 MAC주소, 목적지 MAC주소는 짱구의 MAC주소를 적고 스위치로 전송한다. 마지막으로 스위치는 해당 데이터를 짱구에게 전송하고 짱구는 데이터를 수신한다. 네트워크 계층은 이렇게 다른 LAN영역을 연결하기 위해서 논리적인 주소인 IP주소를 만들어 라우터라는 장치를 이용하는 계층이다. 실제 데이터 전송은 데이터링크 계층, 즉 MAC주소로 하는 것은 달라진 것이 없지만 데이터링크의 한계를 극복하게 해 줬다. 라우터를 넘어가지 않는 영역을 LAN영역이라고 부르고 라우터를 넘어가는 영역을 WAN영역이라 부른다. 네트워크 계층에서는 IP주소와 라우터를 이용해 더 큰 네트워크로 확장하는 방법과 여기서 생긴 문제를 해결하는 프로토콜을 알아보자.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## IP

허브와 스위치로 연결되어 하나의 브로드캐스트 도메인에 있는 네트워크에선 MAC주소만으로 통신할 수 있었다. 하지만 너무 많은 브로드캐스트로 트래픽이 증가하는 걸 해결하기 위해서 논리적인 주소를 만들었는데 이것을 IP주소라고 한다. IP주소는 모든 호스트와 라우터에 할당된다.

> 📚 모든 PC와 라우터의 포트(인터페이스)마다 IP주소 할당. 허브와 스위치는 할당이 안되지만 경우에 따라 할당되는 경우도 존재.

라우터는 IP주소를 이용해서 다른 네트워크에 있는 호스트까지 데이터를 정확하게 전송한다. 그럼 라우터가 IP주소를 어떻게 이용하는지, MAC주소와는 어떤 차이가 있는지 알아보자.

서울에 있는 홍길동이 부산에 있는 임꺽정 집에 가야 하는 상황이라 가정하자. 서울 -> 부산 직행은 없고 대전, 대구를 거쳐서 가야 하는 상황이라고 하자. 홍길동은 서울버스 터미널을 가기 위해서 택시를 타고 택시 기사님께 아래와 같이 말한다.

> 👨‍💼 서울버스 터미널로 가주세요!

그러면 택시기사님은 '서울 버스터미널'이라는 주소를 네비게이션에 입력하고 이동한다. 여기서 출발지 IP주소는 '홍길동 집'이 되고 목적지 IP주소는 '임꺽정 집'이 된다. 출발지 MAC주소는 홍길동 집 주소인 '서울시 은평구 xx길'이고 목적지 MAC주소는 '서울버스 터미널'이 되는 것이다. 서울버스 터미널에 내린 홍길동은 매표소에 이렇게 말한다.

> 👨‍💼임꺽정 집으로 갈건데 표 1개 주세요!

놀랍게도 매표소에는 임꺽정의 개인정보가 저장되어 있어서 직원은 홍길동에게 이렇게 안내한다.

> 👨‍💼 임꺽정 집으로 갈려면 대전행 버스를 타면 돼요!

여기서 매표소는 라우터라고 부르고 매표소에 개인정보가 저장되어 있는 것을 라우팅 테이블이라고 부른다. 대전행 버스를 탄 홍길동은 출발지 IP주소와 목적지 IP주소는 그대로 두고 출발지 MAC주소는 서울버스 터미널, 목적지 MAC주소는 대전버스 터미널로 수정해 이동한다. 대전버스 터미널에 도착한 홍길동은 다시 매표소에서 이렇게 말한다.

> 👨‍💼임꺽정 집으로 갈 건데 표 1개 주세요!

그럼 라우터(직원)는 라우팅 테이블(개인정보)을 참조해 홍길동에게 대구로 가는 표를 준다. 홍길동은 대구행 버스를 탄다. 출발지 MAC주소는 대전버스 터미널, 목적지 MAC주소는 대구버스 터미널로 설정한다. 대구버스 터미널에 도착한 홍길동은 다시 매표소에서 이렇게 말한다.

> 👨‍💼임꺽정 집으로 갈건데 표 1개 주세요!

그럼 라우터는 라우팅 테이블을 참조해 홍길동에게 부산으로 가는 표를 준다. 이제 홍길동은 부산행 버스를 탄다. 출발지 MAC주소는 대구버스 터미널, 목적지 MAC주소는 부산버스 터미널로 설정한다. 부산버스 터미널에 도착한 홍길동은 다시 매표소에서 이렇게 말한다.

> 👨‍💼임꺽정 집으로 갈 건데 표 1개 주세요!

그럼 라우터는 라우팅 테이블을 참조해 홍길동에게 이렇게 말한다.

> 👩🏻‍✈️ 임꺽정은 해운대구 xx길에 살아요. 버스터미널 앞에 택시를 타주세요!

그럼 홍길동은 출발지 MAC주소는 부산버스 터미널, 목적지 MAC주소는 '해운대구 xx길'로 설정하고 택시를 잡아 택시를 탄다.

이렇게 IP주소는 최초 출발지와 최종 목적지 주소를 나타내고 MAC주소를 이용해 실제로 데이터를 전송하기 때문에 중간에 몇 단계의 라우터가 있든 간에 목적지까지 정확하게 데이터가 전송된다. 그러면 실제로 IP주소가 어떻게 생겼는지 보자.

> 192.168.0.1

IP주소는 32bit로 이루어져 있다. 8bit마다 점으로 끊어서 10진수로 표현된 형태이다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## IP 클래스와 서브넷 마스크

IP주소는 8bit 4개로 총 32bit로 구성되어 있다. 8bit는 2^8으로 0~255까지 256개의 수로 표현할 수 있다. 따라서 IP주소는 0.0.0.0부터 255.255.255.255까지 대략 2^32개가 될 수 있다. 2^32개가 되는 IP주소를 효율적으로 관리하기 위해서 클래스라는 것이 등장하였다. 클래스는 A, B, C, D 총 4가지가 있다.

먼저 클래스 A를 알아보자. 클래스 A는 32bit중에서 가장 앞에 있는 비트가 0으로 시작하는 클래스이다. 그리고 가장 앞에 있는 8bit를 네트워크 주소로 사용하고 나머지 24bit는 호스트 주소로 사용한다. 네트워크 주소를 나타내는 8bit에서 가장 첫 번째 비트는 0으로 고정되어 있으므로 7비트로 표현할 수 있는 수는 2^7로 128개가 된다. 즉 0부터 127까지 네트워크 주소로 사용한다. 그러면 나머지 24bit는 호스트 주소로 사용할 수 있는데 24bit는 2^24로 2^24개의 호스트 주소를 사용할 수 있다. 만약 우리에게 네트워크 주소가 1.0.0.0으로 할당되었다면 가장 앞의 8bit는 00000001이 될 것이고 이 네트워크 안에서 1.0.0.0부터 1.255.255.255까지 2^24개의 호스트에 IP를 부여할 수 있다는 의미이다.

> ⚠️ 실제로는 호스트부의 모든 비트가 0이거나 1인 주소는 호스트에 부여할 수 없다. 따라서 2개를 뺀 2^24 - 2개를 할당 가능.

클래스 A는 2^24 - 2개의 호스트를 지정할 수 있는 네트워크가 128개 있다는 것을 기억하자.

다음으로 클래스 B를 알아보자. 클래스 B는 32bit중에서 가장 앞에 있는 2bit가 10으로 시작하는 클래스이다. 그리고 가장 앞에 있는 16bit를 네트워크 주소로 사용하고 나머지 16bit는 호스트 주소로 사용한다. 네트워크 주소를 나타내는 16bit에서 가장 앞 두 비트는 10으로 고정되어 있으므로 14bit로 표현할 수 있는 수 2^14가 된다. 즉 128.0부터 191.255까지 네트워크 주소로 사용이 가능하다. 그러면 나머지 16bit는 2^16로 총 65536개의 호스트 주소를 사용할 수 있다. 만약 우리가 네트워크 주소를 130.0.0.0로 정했다면 이 네트워크는 130.5.0.0부터 130.5.255.255까지 총 65536개의 호스트에 IP를 부여할 수 있다.

> ⚠️ 실제로는 호스트부의 모든 비트가 0이거나 1인 주소는 호스트에 부여할 수 없다. 따라서 2개를 뺀 65534개를 할당 가능.

다음으로 클래스 C를 알아보자. 클래스 C는 32bit중에서 가장 앞에 있는 3bit가 110으로 시작하는 클래스이다. 그리고 가장 앞에 있는 24bit를 네트워크 주소로 사용하고 나머지 8bit는 호스트 주소로 사용한다. 네트워크 주소를 나타내는 24bit에서 가장 앞의 3bit는 110으로 고정되어 있으므로 21bit로 표현할 수 있는 수는 2^21개가 된다. 즉 192.0.0부터 223.255.255까지 네트워크 주소로 사용한다. 그러면 나머지 8bit는 호스트 주소로 사용하는데 8bit는 2^8로 총 256개의 호스트 주소를 사용할 수 있다. 만약 우리가 네트워크 주소를 192.168.0로 정했다면 이 네트워크는 192.168.0.0부터 192.168.0.255까지 총 256개의 호스트에 IP를 부여할 수 있다는 의미이다.

마지막으로 클래스 D를 알아보자. 클래스 D는 32bit중에서 가장 앞에 4bit가 1110으로 시작하는 클래스이다. 그리고 32bit 모두를 네트워크 주소로 사용한다. 클래스 D는 224.0.0.0부터 239.255.255.255까지 나타내는데 호스트를 지정할 수 없어서 멀티캐스트 용도로 사용된다.

> ⚠️ 클래스 D는 특수한 용도로 사용되므로 일반 사용자의 IP주소로 할당되는 일이 없다.

그러면 네트워크 주소와 호스트 주소를 나눌 때 어떻게 표기할까? 만약 클래스 A인 10.1.2.3라는 주소가 있다면 앞에 8bit가 네트워크 주소를 나타낸다. 이 때는 네트워크 주소를 나타내는 8bit를 IP주소 뒤에 /를 적어서 표현한다. 즉 10.1.2.3/8로 표기한다.  그러면 클래스 C인 192.168.0.1은 어떻게 표현할까? 바로 192.168.0.1/24로 표기한다.

> 🙋🏻 그런데 아까 호스트 주소에서 2개를 빼야한다고 했는데 왜 그래요?

호스트 주소에서 모든 비트가 0이거나 1인 경우는 호스트 주소로 사용되지 않는다. 192.168.0.1에서 마지막 8bit가 호스트 주소를 나타낸다. 만약 여기서 호스트 주소의 비트를 전부 0으로 바꾸면 192.168.0.0이 된다. 호스트 주소가 0이면 192.168.0이라는 네트워크의 전체 주소를 나타내는 용도로 쓰이기 때문에 호스트 주소로는 사용이 불가능하다. 여기서 호스트 주소를 전부 1로 변경한다면 192.168.0.255가 된다. 이는 192.168.0이라는 네트워크의 모든 호스트, 즉 브로드캐스트 주소로 사용되기 때문에 호스트 주소로는 사용이 불가능하다.

> 🙋🏻 브로드캐스트는 MAC 주소로 사용하는게 아닌가요? IP주소도 가능한가요?

가능하다. 클래스 C로 구분한 네트워크가 있다고 가정하자. 라우터를 기준으로 왼쪽 네트워크를 192.168.1.0이고 오른쪽 네트워크는 192.168.2.0이라고 하자. 이때 호스트 192.168.1.2에서 목적지 IP주소를 192.168.1.255라고 보낸다면 목적지 MAC주소를 브로드캐스트를 나타내는 F로 모두 채우고 192.168.1.0 네트워크의 모든 호스트로 데이터를 보낸다. 클래스 C에선 최대 254개 호스트에 할당될 수 있으니 최대 254개의 데이터를 보낼 수 있다. 이렇게 라우터를 포함해 모든 호스트로 전송되었다면 브로드캐스트가 잘 동작한 것이다. 여기서 라우터는 다른 네트워크(192.168.2.0)에는 전달하지 않는다. 만약 192.168.1.2에서 목적지 IP주소를 192.168.2.255라고 적고 보내면 라우터에 전달되고 라우터는 목적지 MAC 주소를 브로드캐스트를 나타내는 F로 채우고 192.168.2.0 네트워크의 모든 호스트로 데이터를 전송한다. 이렇게 IP를 클래스로 나눴기 때문에 관리가 편했다.

하지만 IP 클래스는 한계가 존재한다. 사내 통신을 하기 위해선 네트워크를 구축하고 각 호스트에 IP를 할당해야 한다. 회사에 필요한 IP는 300개라고 가정하자. 그렇다면 클래스 C로는 할당 받을 수 없다. 클래스 C는 254개의 호스트만 할당받을 수 있기 때문이다. 따라서 회사에서는 국제 인터넷 주소 관리 기구에 클래스 B를 요청한다. 클래스 B는 65534개의 IP를 할당할 수 있기 때문에 충분하다. 회사에선 IP를 많이 할당해도 남아 돌 정도의 크기인 클래스 B를 할당받아서 좋을 것이다. 하지만 국제 인터넷 주소 관리 기구는 골치가 아플 것이다. 국제 인터넷 주소 관리 기구에서 제공할 수 있는 클래스 B의 네트워크는 16384개이다. 이 작은 회사에 1개를 할당해 줬으니 16383개가 된다. 하지만 이 작은 회사는 IP를 300개만 이용하고 나머지 6만 개가 넘는 IP는 낭비가 된다. 고작 300대의 호스트에 IP를 할당해 주려고 6만 개를 할당할 수 있는 네트워크를 이 회사에 할당함으로 굉장히 비효율적이다. 이렇게 IP주소가 낭비되는 문제를 해결하기 위해 서브넷 마스크가 등장하였다.

서브넷 마스크는 클래스로 나뉘어서 낭비되는 공간을 다시 한번 나누는 기술이다. 조금 전 예시처럼 IP주소가 300개 필요한 회사에 클래스 B의 네트워크를 할당했다고 가정하자. 130.5.0.0으로 앞에 16bit를 네트워크 주소로 뒤에 16bit를 호스트 주소로 사용한다. 여기서 서브넷 마스크는 호스트 주소의 앞 7개의 비트까지 네트워크 주소로 사용한다. 호스트 주소의 앞 7개 까지 1로 채우면 서브넷 마스크는 255.255.254.0으로 표현한다. 그럼 IP주소가 130.5.0.0에 서브넷 마스크를 AND 연산을 하면 네트워크 부가 늘어나고 호스트 부는 줄어들게 된다.

> 이제부터 130.5.0.0에서 네트워크 주소는 서브넷 마스크의 1로 채워진 부분이 된다. (앞의 23bit를 네트워크 주소로 사용)

이제 이 회사는 130.5.0.0부터 130.5.1.255까지 총 512개의 호스트 주소를 할당이 가능해진다. 200개 정도 밖에 낭비가 안 되니 굉장히 효율적이다. IP를 관리하기 위해 클래스로 나눴지만 부족한 IP를 아껴 쓰기 위해서 서브넷 마스크가 등장하게 된 것이다.

IP주소는 부족하다. 네트워크를 처음 구상할 때 43억개의 IP주소면 충분하다고 생각하였지만 인터넷이 폭발적으로 성장하면서 43억 개는 터무니없이 부족하게 되었다. 서브넷 마스크로 절약하긴 했지만 그래도 많이 부족한 현실이다. 한 사람만 보더라도 그 사람이 사용하는 PC, 노트북, 핸드폰, 프린터등 IP주소를 여러 개를 사용한다. 지구에 IP주소를 사용하는 인구가 40억 명이라고 가정하고 한 사람이 3개의 IP주소를 사용한다고 하면 적어도 120억 개의 IP주소가 있어야 한다. 이렇게 사용자의 모든 장치에 고유한 IP를 부여하면 너무 많은 IP주소가 사용되므로 외부와 통신하는 곳에만 고유한 IP를 부여하고 LAN 환경에서는 가상의 IP를 부여하기로 한다. 여기서 가상의 IP를 private IP라고 말한다. 그리고 외부와 통신하는 곳에 부여한 고유 IP를 public IP라고 말한다.

> 📚 집 내부에서는 private IP로 PC, 노트북, 스마트폰을 구분하고 집 외부로 나갈 때 public IP 하나로 나간다.

> 📚 외부에서는 PC, 노트북, 스마트폰을 구분하지 않는다.

private IP범위는 아래와 같다.

> 클래스 A: 10.0.0.0 ~ 10.255.255.255/8
>
> 클래스 B: 172.16.0.0~ 172.31.255.255/12
>
> 클래스 C: 192.168.0.0 ~ 192.168.255.255/16

대부분의 사용자 PC에서 IP주소를 확인하면 이에 포함 될 것이다. 혹은 나와 IP가 같을 수도 있다.

> 🙋🏻 IP는 고유한 것이 아닌가요? 똑같은 주소면 통신이 안될 것 같은데요?

맞다! IP 주소는 고유하다. LAN 영역에서 사용하는 private IP 주소는 라우터를 통해서 다른 네트워크로 이동하기 전에 public IP로 바뀌어서 나간다. public IP로 나가면 고유한 주소로 통신이 가능하다. 이를 NAT라고 하고 NAT는 추후에 알아보자. 아무튼 NAT 덕분에 사용자의 모든 기기에 public IP를 부여하지 않을 수 있게 되어서 IP 주소를 절약할 수 있다. 하지만 이 방법은 NAT Traversal이라는 문제가 발생하는 경우가 있고 IP가 부족한 근본적인 해결방법이 되지 못하므로 IPv6가 개발되었고 이론적으로 무한대로 사용이 가능하다. 현재는 기존의 IPv4와 IPv6를 혼합하여 사용한다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## IP 헤더(패킷)

우리가 데이터를 전송한다면 애플리케이션 계층에서 데이터가 만들어지고 이 데이터는 트랜스포트 계층으로 전달된다. 트랜스포트 계층에서는 받은 데이터에 트랜스포트 계층의 약속을 나타내는 헤더를 붙이고 이렇게 만들어진 전체 데이터를 데이터그램이라고 부른다. 데이터그램은 다시 네트워크 계층으로 전달된다. 네트워크 계층에서 받은 데이터그램에 네트워크 계층의 약속을 나타내는 IP 헤더(네트워크 계층 헤더)를 붙이고 이렇게 만들어진 데이터는 패킷이라고 부른다. 패킷은 다시 데이터링크 계층으로 전달된다. 데이터링크 계층에서는 패킷에 데이터링크 계층의 약속을 나타내는 헤더를 붙이는데 우리는 이더넷을 배웠으니 이더넷 헤더가 붙는다. 이렇게 만들어진 데이터를 프레임이라고 부르고 프레임은 물리계층으로 전달 돼 전기신호로 바뀌어서 케이블을 타고 전송된다. 우리는 이더넷 헤더가 어떻게 생겼는지 알고 있다. 이번 포스트엔 IP 헤더가 어떻게 생겼는지 알아보자.

IP 헤더는 여러 가지가 있는데 하나씩 보자. 가장 먼저 Version이다. Version은 IP 헤더의 버전을 나타내는 4bit로 구성된 필드다. 우리가 사용하고 있는 것은 IPv4이므로 4를 사용한다. 만약 IPv6를 사용한다면 6이 된다. 그 다음으로 Header Length이다. Header Length는 현재 IP 헤더의 크기를 나타내는 4bit로 구성된 필드다. 단위는 32bit이다. 대부분의 IP 헤더의 길이는 20byte이므로 이 값은 거의 5로 구성된다. 다음으로 Type Of Service(TOS) 필드다. 이 필드는 서비스의 우선순위를 나타내는데 거의 사용하지 않는다. 다음으로 Total Packet Length 필드다. 이 필드는 IP 패킷의 크기를 byte 단위로 나타내는 16bit로 구성된 필드다. 16bit로 2^16 byte를 나타낼 수 있다. 최대 크기가 패킷의 크기와 일치한다. 다음으로 Identifier 필드다. 이 필드는 16bit로 구성된 필드다. IP는 패킷을 분할할 수 있는 기능이 있는데 Identifier 필드는 분할된 패킷을 구분하기 위한 용도로 사용한다.

> 분할된 패킷은 Identifier로 순서대로 재조합됨

다음으로 Flags 필드다. 이 필드는 패킷을 분할할지 하지 않을지를 나타내는 3bit로 구성된 필드다.

> 첫 비트는 0으로 고정, 두번째 비트가 0이면 분할, 1이면 분할하지 않는 것이며 세 번째 비트가 0이면 이 패킷이 마지막 조각, 1이면 더 많은 조각이 존재한다.

다음으로 Fragment Offset 필드다. 이 필드는 13bit로 구성되어 있다. 분할된 패킷이 원래 데이터에서 얼마나 떨어져 있는지를 나타내므로 분할 전 데이터그램을 복원할 때 사용된다. 다음으로 Time To Live 필드다. 이 필드는 몇 개의 라우터를 이용할 수 있는 지를 나타내는 8bit로 구성된 필드다. 만약 이 필드의 값이 5라면 5개의 라우터까지 통과할 수 있고 0이 되면 이 패킷은 버려진다. 다음으로 Protocol ID 필드다. 이 필드는 상위계층의 프로토콜이 어떤 프로토콜인지 나타내는 8bit로 구성된 필드다. 다음으로 Header Checksum 필드다. 이 필드는 IP 헤더가 손상됐는지 체크하는 1bit로 구성되어 있는 필드다. 다음으로 Source IP Address 필드는 출발지 IP 주소를 나타내는 32bit로 구성된 필드이다. 다음으로 Destination IP Address 필드는 목적지 IP 주소를 나타내는 32bit로 구성된 필드이다. 다음으로 Options 필드는 주로 사용되지 않지만 테스트용으로 사용되는 가변길이의 필드이다. padding은 Options를 사용하는 경우 길이가 맞지 않을 때 덧붙이는 용도로 사용되는 필드다.

> 패킷의 크기가 32bit 단위가 되도록 padding으로 정확하게 맞춤

padding도 주로 사용되지 않는다. 마지막으로 Data 필드는 상위 계층에서 전달된 데이터(데이터그램)를 나타낸다. 상위계층에서 데이터가 전달되면 IP 헤더를 붙여서 패킷이라는 이름이 되고 이 패킷에 데이터링크의 이더넷 헤더가 붙고 프레임이라는 이름으로 다시 불린다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 라우터

허브와 스위치를 이용하면 콜리전 도메인과 브로드캐스트 도메인으로 통신의 한계가 생기므로 라우터를 이용해 브로드캐스트 도메인을 나눴다. 브로드캐스트 도메인을 나누면서 논리적인 주소가 필요하게 되어 등장한 것이 IP주소이고 IP주소는 고유한 주소를 나타내며 모든 호스트와 라우터의 포트마다 부여된다. private IP는 중복되긴 하지만 NAT을 배우기 전까지 IP는 고유한 주소라고 가정하고 설명하겠다.

라우터는 IP를 다루기 때문에 네트워크 계층에 속한다. 라우터는 CPU와 메모리가 있는 하나의 컴퓨터다. 오직 네트워크에서 데이터를 전송하기 위한 컴퓨터다. 라우터는 사용하는 곳에 따라서 크기와 가격이 천차만별이다. 가정이나 작은 사무실에서 쓰는 라우터는 조그만 크기로 생겼고 가격도 비싸지 않다. 우리나라에선 이런 라우터를 공유기라고 부른다. ISP와 같은 곳에서 사용하는 라우터는 성능이 더 좋아야 하므로 큰 라우터를 사용하는데 가격은 수억 원대이다.

스위치로 만들어진 브로드캐스트 도메인은 LAN영역이라고 부른다. 이런 LAN영역을 넘어서 통신하기 위해서 라우터로 연결되고 라우터를 넘어간 다른 영역을 WAN영역이라고 부른다. 세상에 이렇게 LAN을 연결한 라우터가 수없이 많이 존재하고 라우터끼리 연결한다면 네트워크는 상당히 커지게 된다. 이것이 오늘날 인터넷의 모습니다. 이 라우터들 중에 통신사에서 운영하는 핵심적인 라우터가 있다. 핵심 라우터들은 다른 통신사와 연결되는데 이를 코어 라우터라고 부른다. 우리나라의 KT, SK 브로드밴드, LGU+는 데이터센터에 라우터를 두고 광 케이블을 이용해 연결한다. 이렇게 코어 라우터로 구축된 시스템을 백본이라고 부른다.

> 📚 통신사는 빠르고 많은 처리를 위해서 고성능 라우터를 광 케이블로 연결한 백본을 구축한다.

이렇게 라우터로 복잡하게 연결되어 있을 때 우리가 다른 LAN영역에 있는 사용자에게 데이터를 전송한다면 IP를 이용해 라우터는 최대한 빨리 도달할 수 있는 경로를 적절하게 찾고 이 경로를 통해 데이터를 전송할 수 있게 된다.

> 🙋🏻 가장 가깝고 빠른 경로는 어떻게 적절히 찾나요?

라우팅 프로토콜을 이용해 찾는데 이 부분은 다음 포스트에서 살펴보자.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 라우팅 프로토콜

우리는 라우터와 IP주소를 이용해 다른 네트워크까지 데이터를 전송할 수 있다는 것을 알았다. 라우터는 목적지 네트워크까지 가는 경로를 라우팅 테이블이라는 곳이 미리 저장해 두고 데이터가 들어오면 해당 네트워크로 전달하는 역할을 한다. 그러면 라우팅 테이블이라는 것은 어떤 것이고 어떻게 만들어지는 것일까?

라우팅 테이블은 어떤 네트워크에서 어떤 네트워크로 이동할 때 해당 라우터에서 '어떤 인터페이스(포트)로 이동해야 하는지'가 적혀있는 표이다. 목적지 131.119.254.6인 데이터가 150.150.0.0에 들어온다면 이더넷 2번 포트로 이동하라는 식으로 말이다.

> 🙋🏻 저런 표는 누가 만들어요?

라우팅 테이블을 만드는 방법은 크게 2가지로 분류할 수 있다. 첫번째 방법은 스태틱(정적) 라우팅으로 사람이 직접 주소 하나하나를 지정해 주는 것이다. 두 번째 방법은 다이내믹 라우팅으로 라우터가 다른 라우터들과 정보를 공유해 라우터 스스로 테이블을 만드는 방법이다.

> 🙋🏻 다이나믹 라우팅 방법이 무조건 좋은 방법이겠네요? 사람이 일일이 할 필요가 없으니까요!

대부분은 다이나믹 라우팅이 좋은 방법이다. 하지만 작은 네트워크에서 라우터가 여러 개의 라우터와 연결되지 않고 하나만 연결된 경우라면 스태틱 라우팅으로 직접 만드는 게 더 좋은 방법일 수 있다.

> 📚 라우터A가 라우터 C에만 연결되었다면 데이터를 전송할 곳은 라우터 C 하나로 고정되어 있으므로 스태틱 라우팅으로 라우터 C로만 가도록 설정이 가능하다.

어차피 경로가 하나 밖에 있지 않아서 복잡하지도 않고 직접 적어준다면 라우터가 다른 라우터와 정보를 공유하지 않아서 부하가 적어질 것이다.

> 🙋🏻 그러면 다이나믹 라우팅은 하나의 라우터가 이 세상 모든 라우터와 정보를 교환하나요?

그렇게 되면 라우터가 기억해야 할 정보가 엄청나게 많을 것이다. 라우터의 메모리와 이를 처리할 수 있는 능력에는 한계가 있기 때문에 그렇게 하지는 않는다.

> 🙋🏻 그러면 경로를 못 찾지 않나요?

그걸 대비하여 라우팅 테이블에는 디폴트 라우트라는 것이 있다. 라우팅 테이블에 목적지와 일치하는 정보가 저장되어 있지 않다면 설정한 디폴트 라우트로 무조건 보내는 방법이다. 라우팅 테이블에 디폴트 라우트는 0.0.0.0이나 default로 표현한다. 라우터는 디폴트 라우트 덕분에 자신이 모르는 목적지 주소는 연결된 디폴트 라우트로 보내서 목적지까지 보낼 수 있다.

> 🙋🏻 디폴트 라우트로 설정된 라우터도 목적지를 모르면요?

그러면 디폴트 라우트로 설정된 이 라우터도 디폴트 라우트로 설정된 다른 라우터로 보낼 것이다. 네트워크에서는 라우터를 한번 이동하는 경로를 홉(Hop)이라고 부른다. IP헤더에는 TTL(Time To Live)라는 필드가 있고 이 필드가 0이 되면 패킷은 파기된다고 했다. 만약 이 세상에 존재하지 않는 목적지 주소로 데이터를 전송한다면 라우터들은 계속 디폴트 라우트로 설정된 라우터로 데이터를 전달하다가 TTL이 0이 되면 파기된다.(전달할 때마다 TTL이 감소) 목적지가 없는 데이터가 영원히 네트워크에 존재하는 걸 방지한다.

디폴트 라우트말고도 다른 악속 된 주소가 있다. 바로 127.0.0.1이라는 루프백 주소이다. localhost라고도 불린다. 루프백 주소는 127.0.0.0부터 127.255.255.255(127.0.0.0/8)까지 있지만 보통 127.0.0.1을 사용한다. 이 주소로 데이터를 전송한다면 네트워크로 나가지 않고 자신이 다시 받는다. 루프백 주소는 개발할 대 많이 사용하니 알아두자.
