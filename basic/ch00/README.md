> 이 포스트는 [감자](https://www.inflearn.com/course/그림으로-쉽게-배우는-네트워크# '감자')님의 강의를 참조하여 작성하였습니다.

## 블랙박스

가장 먼저 블랙박스라는 용어에 대해 알아보자. 아래의 질문이 있다.

> Q. 블랙박스는 자동차나 비행기에 있는 녹화장치가 아닌가요?

우리가 배울 블랙박스는 그 블랙박스가 아니다. 과학과 엔지니어링에서 블랙박스는 다른 의미로 쓰인다. 블랙박스란 기능은 알고 있지만 작동원리는 복잡해서 감춰져 있는 시스템을 말한다. 사용자는 입력에 대해서 출력이 어떤지 예측할 수는 있지만 어떻게 동작을 하는지는 관심이 없는 시스템이다. 예를 들어보자. 요리사가 쓰는 가스레인지가 있다고 하자. 요리사는 가스레인지의 손잡이를 돌리면 불이 나온다는 것을 예측할 수 있다. 1단계로 돌리면 약하게, 3단계로 돌리면 강하게 불이 나온다. 하지만 요리사는 가스레인지의 원리가 무엇인지는 알 필요가 없다. 다만 입력(손잡이 돌리기)이 있을 때 출력(불)이 나온다는 것은 확실하게 안다. 여기서 가스레인지가 바로 블랙박스이다. 요리사는 블랙박스 덕분에 불을 피우는 복잡한 과정은 생각하지 않고 자신이 만들 요리에만 집중을 한다.

그럼 아래의 의문점이 들 것이다.

> Q. 우리가 일상에서 볼 수 있는 블랙박스는 무엇이 있을까?

사실 우리가 일상에서 쓰이는 대부분의 장치를 블랙박스라고 한다. 컴퓨터, TV, 냉장고, 청소기, 전등, 샤워기, 변기등 우리가 늘 사용하는 것이다. 우리가 필요로 하는 일의 복잡한 과정을 이러한 장치들이 알아서 해준다. 프로그래밍에서는 함수가 블랙박스에 해당한다. 그러면 아래의 의문점이 들 수 있다.

> Q. 함수는 입력과 출력이 없을 수 있는데 블랙박스에 해당하는가?

그렇다! 입력이 없다는 자체가 입력이 될 수 있다. 마찬가지로 출력이 없다는 것이 출력이 될 수 있다. 블랙박스 안에는 다른 블랙박스들이 존재 할 수 있다. 쉽게 함수 안에 함수가 존재하는 것처럼 말이다. 우리가 컴퓨터에서 파일을 삭제한다면 마우스를 움직여 파일을 우클릭하고 삭제 버튼을 클릭한다. 우리가 이렇게 할 수 있는 것은 운영체제라는 블랙박스 덕분이다. 운영체제는 하나의 큰 블랙박스로 볼 수 있는데 운영체제 안에는 마우스를 처리하는 드라이버, 파일을 관리하는 파일시스템이라는 블랙박스가 존재한다. 이렇듯 블랙박스는 수많은 블랙박스가 조합되어 존재할 수도 있다. 우리는 블랙박스 덕분에 복잡한 문제를 분할정복(Divide and conquer)으로 접근해 비교적 쉽게 해결이 가능하다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 프로토콜

우리는 프로토콜이라는 말을 많이 들어봤을 것이다. 아래의 수많은 프로토콜 중 일부가 있다.

> HTTP, SMTP, FTP, TCP, UDP

이 중에 하나쯤은 들어봤을 것이다. 프로토콜은 무엇일까? 프로토콜을 한 마디로 표현하자면 '약속'이다. 우리의 일상은 수많은 약속이 가득하다. 대화로 예를 들어보자. 두 명의 사람이 대화를 하기 위해 2명 모두 같은 언어를 사용할 줄 알아야 한다. 둘 다 한국어를 사용하거나 영어나 일본어, 중국어등으로 같은 언어를 사용해야 대화가 가능하다. 이는 컴퓨터도 마찬가지다. TCP/IP는 컴퓨터끼리 통신을 하기 위한 프로토콜이다. 발신자와 수신자 사이에서 데이터를 어떻게 전송하고 에러를 처리하는지 정의한다. 하드웨어와 운영체제가 다른 컴퓨터들이 서로 통신한다고 하더라도 TCP/IP를 이용한다면 통신할 수 있다. 이는 인종이나 사는 곳이 달라도 같은 언어를 사용하면 대화가 가능한 것과 같다. 근데 아래의 의문점이 들 수 있다.

> Q. 그런데 왜 이리 길게 프로토콜을 설명해요?

사실 프로토콜의 용어 자체는 그리 어렵지 않다. 하지만 컴퓨터 네트워크를 배운다면 프로토콜을 확실히 알고 넘어가야 한다. 네트워크를 배운다는 것은 수 많은 프로토콜을 배운다는 것이기 때문이다. 네트워크는 단순히 소프트웨어로만 이루어지는 것이 아니라 하드웨어까지 연결되는 굉장히 복잡한 시스템이다. 따라서 분할정복이 필수적인 분야이다. 분할정복을 위해서 네트워크는 여러 계층으로 나누었다. 자세한 내용은 다음 포스트에서 진행해 보겠다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 네트워크의 역사

오늘날 네트워크는 많은 장치가 복잡하게 이루어져 있어서 처음 접하면 굉장히 복잡하게 느껴진다. 왜 이렇게 많은 장치가 등장했는지 궁금증이 생긴다. 우리는 운영체제 포스트에서도 먼저 역사부터 알아보았다. 운영체제도 처음에는 굉장히 단순한 구조였지만 사용자의 요구에 맞춰서 발전하다 보니 복잡해졌고 생각지도 못한 문제가 발생해 이를 해결하기 위한 복잡한 알고리즘도 발명되었다. 네트워크도 마찬가지다. 지금의 네트워크가 왜 이렇게 복잡해졌는지는 역사를 알면 이해가 된다.

이번 포스트에는 네트워크의 역사의 큰 흐름을 간단하게 알아보자. 네트워크의 역사를 알기 위해서 컴퓨터의 역사와 운영체제의 역사를 같이 알아야한다. 1943년부터 미군 지휘하에 펜실베니아 대학교에서 개발된 컴퓨터는 에니악이다. 이는 세계에서 가장 큰 스케일의 전자디지털 계산기이다. 에니악은 입출력 도중에는 CPU로 계산이 불가능했다. 비싼 컴퓨터를 최대한 이용해야 하는데 쉬는 시간이 생긴 것이다. 따라서 컴퓨터 시스템 개발자들은 "어떻게 하면 CPU를 최대한 많이 사용할 수 있을 까?"라는 고민을 하게 되었다. 1950년대 초에 직접회로가 개발되면서 진공관과 전선으로 만들어진 컴퓨터의 크기는 작아졌다. 이때는 개발자가 펀치카드에 구멍을 뚫어서 프로그래밍하였다. 1950년대 중반에 입출력 관리자를 만들어 입출력 작업 도중에도 CPU는 계산할 수 있도록 만들어졌다. 1960년대에는 싱글스트림배치시스템의 한계를 극복한 시분할 시스템을 개발해 CPU의 사용률을 올렸다. 시분할 시스템이 개발되면서 여러 사용자가 터미널이라는 기계를 컴퓨터에 연결해 CPU를 동시에 사용할 수 있었고 오퍼레이터라는 직업은 사라지고 운영체제가 그 자리를 대신하였다. 동시에 여러 개의 프로그램을 실행하다 보니 관리할 것들이 많아지고 문제도 많이 발생함으로 미국의 대학들은 이것이 굉장히 복잡하고 중요한 문제라는 것을 깨닫고 운영체제를 하나의 학문으로 만들었다. 이렇게 컴퓨터 시스템 개발자들은 CPU 사용률과 비용절감의 노력으로 컴퓨터와 운영체제를 발전시켜 왔다. 컴퓨터 네트워크는 컴퓨터, 운영제체와 같이 발전했다. 하나의 컴퓨터를 여러 사용자가 나누어 쓸 수 있게 되어서 CPU 사용률은 굉장히 좋아졌다. 하지만 여기에 만족하지 않고 여러 컴퓨터가 서로 데이터를 공유하면 더 효과적으로 작업할 수 있겠다는 아이디어를 생각해 낸다. 냉전시대에 미국은 소련에게 기술이 밀리지 않기 위해서 ARPA를 설립했다. 과학기술연구를 더 잘하기 위해서이다. 만약 대규모 컴퓨터 네트워크를 만든다면 연구내용을 공유하기도 쉽고 중복된 연구를 하느라 인력 낭비를 할 일이 없어질 것이다. 1962년 ARPA의 리클라이더는 수천 대, 수만 대의 컴퓨터가 연결되는 '은하계 네트워크'를 제안했다. 이렇게 계획한 대규모 컴퓨터 네트워크는 ARPAnet이라는 이름이 붙였다. ARPAnet에서는 오늘날의 라우터에 해당하는 IMP라는 장치를 전화선으로 연결하고 IMP와 사용자(Host)를 연결하는 방식을 구상했다. 1969년에 UCLA에서 SRI로 최초의 패킷 교환 메시지를 보냈다. 1969년 말에는 UCSB, UU까지 총 4개가 연결되었다. 다음 해인 1970년도엔 이렇게 연결된 노들을 제어하기 위한 Network Control Protocol(NCP)을 만들었다. 연결을 원하는 기관이 많아지자 ARPAnet은 빠르게 커지기 시작했다. 하지만 NCP는 등록된 네트워크만을 사용할 수 있기 때문에 자율적인 확장이 쉽지 않아서 오늘날의 인터넷과는 거리가 있다. 1973년 Vint Cerf는 NCP의 단점을 해결한 프로토콜은 발표했고 이것이 오늘날의 인터넷 프로토콜인 TCP/IP이다. TCP/IP는 확정성이 좋았기 때문에 NCP의 비중은 점점 줄어들고 TCP/IP의 비중은 점점 늘어났다. 이렇게 TCP/IP의 사용이 폭발적으로 늘어나 ARPAnet은 공식적으로 TCP/IP를 통신 프로토콜로 채택했다. 또한 1985년엔 유닉스 운영체제에 TCP/IP가 기본적으로 내장되었고 이로써 TCP/IP는 현재 인터넷을 이루는 주류가 된 것이다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## TCP/IP 5계층, OSI 7계층

이전 포스트에서 네트워크의 역사를 알아보면서 TCP/IP가 어떻게 주류 프로토콜이 되었는지를 알아보았다. TCP/IP는 ARPAnet을 통해서 많은 시행착오를 거쳤기 때문에 굉장히 실용적인 프로토콜이다. ARPAnet이 인터넷으로 발전하면서 TCP/IP는 인터넷 표준이 되었다. 즉, TCP/IP는 업계 표준이라는 말이다. 우리가 지금 사용하고 있는 프로토콜도 TCP/IP다. TCP/IP는 복잡한 네트워크를 다양한 제조사와 사람드링 쉽게 사용할 수 있도록 네트워크의 기능을 크기 나눠서 블랙박스화 시킨다. 이렇게 기능을 나눈 것을 계층이라고 하고 TCP/IP는 5개의 계층으로 나눈다.

첫 번째 계층은 물리계층이다. 이 계층은 실제로 데이터를 물리적으로 전송해 준다. 이 계층은 실제로 데이터를 물리적으로 전송해준다. 데이터를 전기신호로 변환하고 전기신호를 다시 데이터로 복원한다. 랜카드와 케이블만 있다면 두 컴퓨터가 통신이 가능한데 이는 물리계층 덕분이다. 이 계층에선 데이터를 전달만 할 뿐 어떻게 보내는 것이 효율적인지는 생각하지 않는다.  두 번째 계층은 데이터 링크 계층이다. 여러 개의 기기가 연결돼 있더라도 MAC주소라는 고유한 주소로 기기를 잘 분류한다. 세 번째 계층은 네트워크 계층이다. 이 계층은 복잡하게 연결된 네트워크에서 IP주소를 이용해 출발지부터 목적지까지 정확하게 데이터를 전달한다. 네 번째 계층은 트랜스포트 계층이다. 이 계층은 두 컴퓨터 사이의 신뢰성 있는 데이터 전송을 보장하고 포트를 이용하여 사용자의 특정 애플리케이션으로 정확하게 전달한다. 트랜스포트 계층은 네트워크 계층 위에서 동작하기 때문에 두 컴퓨터 사이의 연결을 보장하는 일에만 집중할 수 있다. 실제로 데이터를 전달하는 역할은 아래에 있는 계층들이 해준다. 다섯번째 계층은 어플리케이션 계층이다. 이 계층은 사용자와 가장 가까운 계층이다. HTTP나 FTP, SSH 등 사용자가 직접 다루는 애플리케이션이 이 계층이 해당한다. 애플리케이션 계층은 트랜스포트 계층 위에서 동작하기 때문에 애플리케이션이 하는 일에만 집중할 수 있다. 신뢰성 있는 데이터 보장, 데이터 전송은 아래 계층들이 담당한다. 이렇게 계층화가 돼 있기 때문에 사용자는 애플리케이션 계층만 알고 있어도 프로그램을 만들 수 있다. 그런 에 아래와 같은 의문점이 든다.

> Q. 그런데 네트워크 애기만 나오면 OSI 7 계층 애기가 나오는데 그게 뭘까?

네트워크 얘기를 하면 빠질 수 없는 게 OSI 7계층이다. OSI 7계층은 TCP/IP 5계층과 같은 네트워크를 위한 표준 프로토콜이다. 국제 표준화 기구인 ISO에서 만든 국제 표준 프로토콜이다. 하지만 현실세계에서 동작하는 인터넷은 OSI 모델로 이루어져 있지 않고 TCP/IP 모델로 이루어져 있다. 왜 그럴까? 역사를 살펴보면 알 수 있다. 인터넷의 시작은 ARPAnet이었다. ARPAnet은 정식으로 TCP/IP를 채택했고 당시에 많은 사용자가 유닉스 운영체제를 사용했는데 이 운영체제에서는 TCP/IP가 내장되어 있었다. TCP/IP가 빠르게 퍼질 수 밖에 없는 상황이다. 하지만 OSI 모델은 더 늦게 만들어진 국제 표준이라 이미 자리잡은 TCP/IP를 밀어내기엔 역부족이다. 따라서 국제표준은 OSI 7계층 모델이지만 현업에서는 TCP/IP 5계층이 사용되고 있는 것이다. 그래서 우리는 앞으로 현업 표준인 TCP/IP 5계층에 대해 공부를 할 것이다. 필요하면 이 계층과 OSI 7계층과 비교를 하면서 말이다.

TCP/IP 5계층 모델에서는 애플리케이션 계층은 OSI 7계층의 세션계층, 프리젠테에션 계층, 애플리케이션 계층을 하나로 표현하는 계층으로 볼 수 있다. 나머지 계층은 1:1 매칭되므로 크게 다를 것이 없다.

우리가 애플리케이션에서 데이터를 전송하면 어떤 흐름으로 TCP/IP 5계층이 동작할까? 웹브라우저에서 웹서버로 데이터를 전송한다고 가정하자. 웹브라우저는 HTTP를 사용하기 때문에 웹서버로 전송할 HTTP 메시지가 만들어진다. 애플리케이션 계층은 이 데이터를 4계층, 즉 트랜스포트 계층으로 보낸다. 트랜스포트 계층에서는 애플리케이션 계층에서 받은 데이터에 트랜스포트 계층의 약속을 나타내는 데이터를 맨 앞에 덧붙인다. 맨 앞에 머리 쪽에 붙여졌다고 해서 헤더라고 부른다. 이렇게 애플리케이션의 데이터와 트랜스포트 헤더가 합쳐진 전체 데이터를 데이트그램 또는 세그먼트라고 부른다. 이제 이 데이터그램을 3계층 즉 네트워크 계층으로 보낸다. 네트워크 계층에선 트랜스포트 계층에서 받은 데이터그램을 데이터로 취급한다. 여기서 데이터에 네트워크 계층의 약속을 나타내는 헤더를 덧붙인다. 이렇게 트랜스포트 계층의 데이터그램과 네트워크 계층의 헤더가 합쳐진 전체 데이터를 패킷이라고 부른다. 그리고 이 패킷을 2계층, 즉 데이터링크 계층으로 보낸다. 데이터링크 계층에선 네트워크 계층에서 받은 패킷에 데이터링크 계층의 헤더와 트레일러가 덧붙인다. 이렇게 네트워크 계층의 패킷과 데이터링크 계층의 헤더가 합쳐진 전체 데이터를 프레임이라고 부른다. 그리고 이 프레임을 1계층, 즉 물리계층으로 보낸다. 물리계층에선 데이터링크 계층으로부터 받은 프레임을 전기신호로 바꿔서 물리적으로 전송한다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 서버와 클라이언트

서버와 클라이언트라는 말은 무엇일까? 이해를 위해 영어사전을 참조했다. 영어로 serve는 "제공하다"라는 의미를 지닌다. 어떤 것을 제공하는 사람을 서버라고 부른다. 우리는 식당에 가면 종업원이 서빙을 한다. 즉 서버가 서빙을 하는 것이다. 그럼 종업원에게 서비스를 요청하는 우리와 같은 고객은 뭐라 부를까? 바로 클라이언트이다. 클라이언트가 서버에게 서비스를 요청하면 서버는 해당 서비스에 대한 응답을 한다. CS에서 말하는 서버, 클라이언트도 똑같은 뜻이다. 클라이언트 요청에 파일을 저장하거나 제공해 주는 서버를 파일서버라고 부르고 웹서비스를 제공해 주는 서버를 웹서버라고 부른다. 아래의 질문이 있다.

> Q. 서버를 들었을 땐 엄청 크고 멋진 장치인데 그거랑 뭐가 다를까?

서버라고 하면 엄청나게 큰 장치만 생각하며 막연하게 생각하신 분들이 많을 것이다. 컴퓨터의 외형으로 서버와 클라이언트를 나누는 것이 아니다. 서버는 단지 서비스를 제공해준다는 것만 기억하면 될 것이다. 우리가 사용하는 컴퓨터도 언제든지 서버가 될 수 있다.

나는 대학생 때 캡스톤 디자인으로 라즈베리파이라는 초소형 컴퓨터를 구입하여 서버로 이용하기도 했다. 손바닥만한 작은 크기지만 서버의 역할을 잘 수행하였다. 다만 대부분의 서버는 많은 클라이언트의 요청을 처리해야 하므로 성능이 중요하다. 따라서 하드웨어의 크기도 커진 것이다. 하지만 서버와 클라이언트에서 중요한 것은 하드웨어의 크기가 아니라 "누가 요청을 하고 누가 응답을 받는가"이다.
