> 이 포스트는 [감자](https://www.inflearn.com/course/그림으로-쉽게-배우는-네트워크# '감자')님의 강의를 참조하여 작성하였습니다.

## 블랙박스

가장 먼저 블랙박스라는 용어에 대해 알아보자. 아래의 질문이 있다.

> Q. 블랙박스는 자동차나 비행기에 있는 녹화장치가 아닌가요?

우리가 배울 블랙박스는 그 블랙박스가 아니다. 과학과 엔지니어링에서 블랙박스는 다른 의미로 쓰인다. 블랙박스란 기능은 알고 있지만 작동원리는 복잡해서 감춰져 있는 시스템을 말한다. 사용자는 입력에 대해서 출력이 어떤지 예측할 수는 있지만 어떻게 동작을 하는지는 관심이 없는 시스템이다. 예를 들어보자. 요리사가 쓰는 가스레인지가 있다고 하자. 요리사는 가스레인지의 손잡이를 돌리면 불이 나온다는 것을 예측할 수 있다. 1단계로 돌리면 약하게, 3단계로 돌리면 강하게 불이 나온다. 하지만 요리사는 가스레인지의 원리가 무엇인지는 알 필요가 없다. 다만 입력(손잡이 돌리기)이 있을 때 출력(불)이 나온다는 것은 확실하게 안다. 여기서 가스레인지가 바로 블랙박스이다. 요리사는 블랙박스 덕분에 불을 피우는 복잡한 과정은 생각하지 않고 자신이 만들 요리에만 집중을 한다.

그럼 아래의 의문점이 들 것이다.

> Q. 우리가 일상에서 볼 수 있는 블랙박스는 무엇이 있을까?

사실 우리가 일상에서 쓰이는 대부분의 장치를 블랙박스라고 한다. 컴퓨터, TV, 냉장고, 청소기, 전등, 샤워기, 변기등 우리가 늘 사용하는 것이다. 우리가 필요로 하는 일의 복잡한 과정을 이러한 장치들이 알아서 해준다. 프로그래밍에서는 함수가 블랙박스에 해당한다. 그러면 아래의 의문점이 들 수 있다.

> Q. 함수는 입력과 출력이 없을 수 있는데 블랙박스에 해당하는가?

그렇다! 입력이 없다는 자체가 입력이 될 수 있다. 마찬가지로 출력이 없다는 것이 출력이 될 수 있다. 블랙박스 안에는 다른 블랙박스들이 존재 할 수 있다. 쉽게 함수 안에 함수가 존재하는 것처럼 말이다. 우리가 컴퓨터에서 파일을 삭제한다면 마우스를 움직여 파일을 우클릭하고 삭제 버튼을 클릭한다. 우리가 이렇게 할 수 있는 것은 운영체제라는 블랙박스 덕분이다. 운영체제는 하나의 큰 블랙박스로 볼 수 있는데 운영체제 안에는 마우스를 처리하는 드라이버, 파일을 관리하는 파일시스템이라는 블랙박스가 존재한다. 이렇듯 블랙박스는 수많은 블랙박스가 조합되어 존재할 수도 있다. 우리는 블랙박스 덕분에 복잡한 문제를 분할정복(Divide and conquer)으로 접근해 비교적 쉽게 해결이 가능하다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 프로토콜

우리는 프로토콜이라는 말을 많이 들어봤을 것이다. 아래의 수많은 프로토콜 중 일부가 있다.

> HTTP, SMTP, FTP, TCP, UDP

이 중에 하나쯤은 들어봤을 것이다. 프로토콜은 무엇일까? 프로토콜을 한 마디로 표현하자면 '약속'이다. 우리의 일상은 수많은 약속이 가득하다. 대화로 예를 들어보자. 두 명의 사람이 대화를 하기 위해 2명 모두 같은 언어를 사용할 줄 알아야 한다. 둘 다 한국어를 사용하거나 영어나 일본어, 중국어등으로 같은 언어를 사용해야 대화가 가능하다. 이는 컴퓨터도 마찬가지다. TCP/IP는 컴퓨터끼리 통신을 하기 위한 프로토콜이다. 발신자와 수신자 사이에서 데이터를 어떻게 전송하고 에러를 처리하는지 정의한다. 하드웨어와 운영체제가 다른 컴퓨터들이 서로 통신한다고 하더라도 TCP/IP를 이용한다면 통신할 수 있다. 이는 인종이나 사는 곳이 달라도 같은 언어를 사용하면 대화가 가능한 것과 같다. 근데 아래의 의문점이 들 수 있다.

> Q. 그런데 왜 이리 길게 프로토콜을 설명해요?

사실 프로토콜의 용어 자체는 그리 어렵지 않다. 하지만 컴퓨터 네트워크를 배운다면 프로토콜을 확실히 알고 넘어가야 한다. 네트워크를 배운다는 것은 수 많은 프로토콜을 배운다는 것이기 때문이다. 네트워크는 단순히 소프트웨어로만 이루어지는 것이 아니라 하드웨어까지 연결되는 굉장히 복잡한 시스템이다. 따라서 분할정복이 필수적인 분야이다. 분할정복을 위해서 네트워크는 여러 계층으로 나누었다. 자세한 내용은 다음 포스트에서 진행해 보겠다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 네트워크의 역사

오늘날 네트워크는 많은 장치가 복잡하게 이루어져 있어서 처음 접하면 굉장히 복잡하게 느껴진다. 왜 이렇게 많은 장치가 등장했는지 궁금증이 생긴다. 우리는 운영체제 포스트에서도 먼저 역사부터 알아보았다. 운영체제도 처음에는 굉장히 단순한 구조였지만 사용자의 요구에 맞춰서 발전하다 보니 복잡해졌고 생각지도 못한 문제가 발생해 이를 해결하기 위한 복잡한 알고리즘도 발명되었다. 네트워크도 마찬가지다. 지금의 네트워크가 왜 이렇게 복잡해졌는지는 역사를 알면 이해가 된다.

이번 포스트에는 네트워크의 역사의 큰 흐름을 간단하게 알아보자. 네트워크의 역사를 알기 위해서 컴퓨터의 역사와 운영체제의 역사를 같이 알아야한다. 1943년부터 미군 지휘하에 펜실베니아 대학교에서 개발된 컴퓨터는 에니악이다. 이는 세계에서 가장 큰 스케일의 전자디지털 계산기이다. 에니악은 입출력 도중에는 CPU로 계산이 불가능했다. 비싼 컴퓨터를 최대한 이용해야 하는데 쉬는 시간이 생긴 것이다. 따라서 컴퓨터 시스템 개발자들은 "어떻게 하면 CPU를 최대한 많이 사용할 수 있을 까?"라는 고민을 하게 되었다. 1950년대 초에 직접회로가 개발되면서 진공관과 전선으로 만들어진 컴퓨터의 크기는 작아졌다. 이때는 개발자가 펀치카드에 구멍을 뚫어서 프로그래밍하였다. 1950년대 중반에 입출력 관리자를 만들어 입출력 작업 도중에도 CPU는 계산할 수 있도록 만들어졌다. 1960년대에는 싱글스트림배치시스템의 한계를 극복한 시분할 시스템을 개발해 CPU의 사용률을 올렸다. 시분할 시스템이 개발되면서 여러 사용자가 터미널이라는 기계를 컴퓨터에 연결해 CPU를 동시에 사용할 수 있었고 오퍼레이터라는 직업은 사라지고 운영체제가 그 자리를 대신하였다. 동시에 여러 개의 프로그램을 실행하다 보니 관리할 것들이 많아지고 문제도 많이 발생함으로 미국의 대학들은 이것이 굉장히 복잡하고 중요한 문제라는 것을 깨닫고 운영체제를 하나의 학문으로 만들었다. 이렇게 컴퓨터 시스템 개발자들은 CPU 사용률과 비용절감의 노력으로 컴퓨터와 운영체제를 발전시켜 왔다. 컴퓨터 네트워크는 컴퓨터, 운영제체와 같이 발전했다. 하나의 컴퓨터를 여러 사용자가 나누어 쓸 수 있게 되어서 CPU 사용률은 굉장히 좋아졌다. 하지만 여기에 만족하지 않고 여러 컴퓨터가 서로 데이터를 공유하면 더 효과적으로 작업할 수 있겠다는 아이디어를 생각해 낸다. 냉전시대에 미국은 소련에게 기술이 밀리지 않기 위해서 ARPA를 설립했다. 과학기술연구를 더 잘하기 위해서이다. 만약 대규모 컴퓨터 네트워크를 만든다면 연구내용을 공유하기도 쉽고 중복된 연구를 하느라 인력 낭비를 할 일이 없어질 것이다. 1962년 ARPA의 리클라이더는 수천 대, 수만 대의 컴퓨터가 연결되는 '은하계 네트워크'를 제안했다. 이렇게 계획한 대규모 컴퓨터 네트워크는 ARPAnet이라는 이름이 붙였다. ARPAnet에서는 오늘날의 라우터에 해당하는 IMP라는 장치를 전화선으로 연결하고 IMP와 사용자(Host)를 연결하는 방식을 구상했다. 1969년에 UCLA에서 SRI로 최초의 패킷 교환 메시지를 보냈다. 1969년 말에는 UCSB, UU까지 총 4개가 연결되었다. 다음 해인 1970년도엔 이렇게 연결된 노들을 제어하기 위한 Network Control Protocol(NCP)을 만들었다. 연결을 원하는 기관이 많아지자 ARPAnet은 빠르게 커지기 시작했다. 하지만 NCP는 등록된 네트워크만을 사용할 수 있기 때문에 자율적인 확장이 쉽지 않아서 오늘날의 인터넷과는 거리가 있다. 1973년 Vint Cerf는 NCP의 단점을 해결한 프로토콜은 발표했고 이것이 오늘날의 인터넷 프로토콜인 TCP/IP이다. TCP/IP는 확정성이 좋았기 때문에 NCP의 비중은 점점 줄어들고 TCP/IP의 비중은 점점 늘어났다. 이렇게 TCP/IP의 사용이 폭발적으로 늘어나 ARPAnet은 공식적으로 TCP/IP를 통신 프로토콜로 채택했다. 또한 1985년엔 유닉스 운영체제에 TCP/IP가 기본적으로 내장되었고 이로써 TCP/IP는 현재 인터넷을 이루는 주류가 된 것이다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## TCP/IP 5계층, OSI 7계층

이전 포스트에서 네트워크의 역사를 알아보면서 TCP/IP가 어떻게 주류 프로토콜이 되었는지를 알아보았다. TCP/IP는 ARPAnet을 통해서 많은 시행착오를 거쳤기 때문에 굉장히 실용적인 프로토콜이다. ARPAnet이 인터넷으로 발전하면서 TCP/IP는 인터넷 표준이 되었다. 즉, TCP/IP는 업계 표준이라는 말이다. 우리가 지금 사용하고 있는 프로토콜도 TCP/IP다. TCP/IP는 복잡한 네트워크를 다양한 제조사와 사람드링 쉽게 사용할 수 있도록 네트워크의 기능을 크기 나눠서 블랙박스화 시킨다. 이렇게 기능을 나눈 것을 계층이라고 하고 TCP/IP는 5개의 계층으로 나눈다.

첫 번째 계층은 물리계층이다. 이 계층은 실제로 데이터를 물리적으로 전송해 준다. 이 계층은 실제로 데이터를 물리적으로 전송해준다. 데이터를 전기신호로 변환하고 전기신호를 다시 데이터로 복원한다. 랜카드와 케이블만 있다면 두 컴퓨터가 통신이 가능한데 이는 물리계층 덕분이다. 이 계층에선 데이터를 전달만 할 뿐 어떻게 보내는 것이 효율적인지는 생각하지 않는다.  두 번째 계층은 데이터 링크 계층이다. 여러 개의 기기가 연결돼 있더라도 MAC주소라는 고유한 주소로 기기를 잘 분류한다. 세 번째 계층은 네트워크 계층이다. 이 계층은 복잡하게 연결된 네트워크에서 IP주소를 이용해 출발지부터 목적지까지 정확하게 데이터를 전달한다. 네 번째 계층은 트랜스포트 계층이다. 이 계층은 두 컴퓨터 사이의 신뢰성 있는 데이터 전송을 보장하고 포트를 이용하여 사용자의 특정 애플리케이션으로 정확하게 전달한다. 트랜스포트 계층은 네트워크 계층 위에서 동작하기 때문에 두 컴퓨터 사이의 연결을 보장하는 일에만 집중할 수 있다. 실제로 데이터를 전달하는 역할은 아래에 있는 계층들이 해준다. 다섯번째 계층은 어플리케이션 계층이다. 이 계층은 사용자와 가장 가까운 계층이다. HTTP나 FTP, SSH 등 사용자가 직접 다루는 애플리케이션이 이 계층이 해당한다. 애플리케이션 계층은 트랜스포트 계층 위에서 동작하기 때문에 애플리케이션이 하는 일에만 집중할 수 있다. 신뢰성 있는 데이터 보장, 데이터 전송은 아래 계층들이 담당한다. 이렇게 계층화가 돼 있기 때문에 사용자는 애플리케이션 계층만 알고 있어도 프로그램을 만들 수 있다. 그런 에 아래와 같은 의문점이 든다.

> Q. 그런데 네트워크 애기만 나오면 OSI 7 계층 애기가 나오는데 그게 뭘까?

네트워크 얘기를 하면 빠질 수 없는 게 OSI 7계층이다. OSI 7계층은 TCP/IP 5계층과 같은 네트워크를 위한 표준 프로토콜이다. 국제 표준화 기구인 ISO에서 만든 국제 표준 프로토콜이다. 하지만 현실세계에서 동작하는 인터넷은 OSI 모델로 이루어져 있지 않고 TCP/IP 모델로 이루어져 있다. 왜 그럴까? 역사를 살펴보면 알 수 있다. 인터넷의 시작은 ARPAnet이었다. ARPAnet은 정식으로 TCP/IP를 채택했고 당시에 많은 사용자가 유닉스 운영체제를 사용했는데 이 운영체제에서는 TCP/IP가 내장되어 있었다. TCP/IP가 빠르게 퍼질 수 밖에 없는 상황이다. 하지만 OSI 모델은 더 늦게 만들어진 국제 표준이라 이미 자리잡은 TCP/IP를 밀어내기엔 역부족이다. 따라서 국제표준은 OSI 7계층 모델이지만 현업에서는 TCP/IP 5계층이 사용되고 있는 것이다. 그래서 우리는 앞으로 현업 표준인 TCP/IP 5계층에 대해 공부를 할 것이다. 필요하면 이 계층과 OSI 7계층과 비교를 하면서 말이다.

TCP/IP 5계층 모델에서는 애플리케이션 계층은 OSI 7계층의 세션계층, 프리젠테에션 계층, 애플리케이션 계층을 하나로 표현하는 계층으로 볼 수 있다. 나머지 계층은 1:1 매칭되므로 크게 다를 것이 없다.

우리가 애플리케이션에서 데이터를 전송하면 어떤 흐름으로 TCP/IP 5계층이 동작할까? 웹브라우저에서 웹서버로 데이터를 전송한다고 가정하자. 웹브라우저는 HTTP를 사용하기 때문에 웹서버로 전송할 HTTP 메시지가 만들어진다. 애플리케이션 계층은 이 데이터를 4계층, 즉 트랜스포트 계층으로 보낸다. 트랜스포트 계층에서는 애플리케이션 계층에서 받은 데이터에 트랜스포트 계층의 약속을 나타내는 데이터를 맨 앞에 덧붙인다. 맨 앞에 머리 쪽에 붙여졌다고 해서 헤더라고 부른다. 이렇게 애플리케이션의 데이터와 트랜스포트 헤더가 합쳐진 전체 데이터를 데이트그램 또는 세그먼트라고 부른다. 이제 이 데이터그램을 3계층 즉 네트워크 계층으로 보낸다. 네트워크 계층에선 트랜스포트 계층에서 받은 데이터그램을 데이터로 취급한다. 여기서 데이터에 네트워크 계층의 약속을 나타내는 헤더를 덧붙인다. 이렇게 트랜스포트 계층의 데이터그램과 네트워크 계층의 헤더가 합쳐진 전체 데이터를 패킷이라고 부른다. 그리고 이 패킷을 2계층, 즉 데이터링크 계층으로 보낸다. 데이터링크 계층에선 네트워크 계층에서 받은 패킷에 데이터링크 계층의 헤더와 트레일러가 덧붙인다. 이렇게 네트워크 계층의 패킷과 데이터링크 계층의 헤더가 합쳐진 전체 데이터를 프레임이라고 부른다. 그리고 이 프레임을 1계층, 즉 물리계층으로 보낸다. 물리계층에선 데이터링크 계층으로부터 받은 프레임을 전기신호로 바꿔서 물리적으로 전송한다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 서버와 클라이언트

서버와 클라이언트라는 말은 무엇일까? 이해를 위해 영어사전을 참조했다. 영어로 serve는 "제공하다"라는 의미를 지닌다. 어떤 것을 제공하는 사람을 서버라고 부른다. 우리는 식당에 가면 종업원이 서빙을 한다. 즉 서버가 서빙을 하는 것이다. 그럼 종업원에게 서비스를 요청하는 우리와 같은 고객은 뭐라 부를까? 바로 클라이언트이다. 클라이언트가 서버에게 서비스를 요청하면 서버는 해당 서비스에 대한 응답을 한다. CS에서 말하는 서버, 클라이언트도 똑같은 뜻이다. 클라이언트 요청에 파일을 저장하거나 제공해 주는 서버를 파일서버라고 부르고 웹서비스를 제공해 주는 서버를 웹서버라고 부른다. 아래의 질문이 있다.

> Q. 서버를 들었을 땐 엄청 크고 멋진 장치인데 그거랑 뭐가 다를까?

서버라고 하면 엄청나게 큰 장치만 생각하며 막연하게 생각하신 분들이 많을 것이다. 컴퓨터의 외형으로 서버와 클라이언트를 나누는 것이 아니다. 서버는 단지 서비스를 제공해준다는 것만 기억하면 될 것이다. 우리가 사용하는 컴퓨터도 언제든지 서버가 될 수 있다.

나는 대학생 때 캡스톤 디자인으로 라즈베리파이라는 초소형 컴퓨터를 구입하여 서버로 이용하기도 했다. 손바닥만한 작은 크기지만 서버의 역할을 잘 수행하였다. 다만 대부분의 서버는 많은 클라이언트의 요청을 처리해야 하므로 성능이 중요하다. 따라서 하드웨어의 크기도 커진 것이다. 하지만 서버와 클라이언트에서 중요한 것은 하드웨어의 크기가 아니라 "누가 요청을 하고 누가 응답을 받는가"이다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 구글을 검색하면 어떤 일이 일어날까?

강사님처럼 저도 학교에서 네트워크 전공 수업을 듣고 찝찝합이 계속 남아있었다. 네트워크 이론을 배웠지만 실제로 이것들이 어떻게 적용되고 흘러가는지 이해가 되지를 않았다. 인터넷이 어떻게 동작하는지 개념적으로는 알고 있었지만 인터넷이 안되면 인터넷 수리기사님을 불렀고 인터넷 수리기사남이 오셨을 때 수리하시고 가는 게 정말 신기하게만 느껴졌다. 이번 포스트에서는 이와 같은 궁금증이 생기지 않도록 예시를 들면서 인터넷이 어떻게 동작하는지 알아보자. 다만 지금은 네트워크 이론에 대해 자세히 다루지 않았기에 물리적으로 어떤 흐름으로 거쳐가는지만 살펴보자.

웹 브라우저에 google.com을 입력했을 때 어떤 일이 일어날까? 일반 사람들은 아래와 같이 생각할 것이다.

> 그냥 구글에서 데이터 보내주는거겠지?

이번 포스트에서 마법 같은 인터넷이 어떻게 동작하는지 알아보자. 웹 브라우저에 google.com을 입력한다는 것은 구글의 웹 서버에 웹 페이지를 요청하는 것이다. 저의 웹 페이지 요청 데이터는 LAN선이나 전파를 통해 방에 있는 공유기(라우터)로 이동한다. 저는 LAN선을 이용하고 있으므로 제가 요청한 데이터는 케이블을 통해 유무선 공유기로 전달된다. 더의 집에는 거실에 공유기가 설치되어 있다. 이 공유기는 통신사(ISP)에서 설치한 모뎀에 연결된다. 그럼 모뎀은 어디에 존재할까? 집마다 차이는 있겠지만 우리 집 같은 경우에는 다용도실 벽면에 있는 세대통신단자함(CDB)에 설치되어 있다. 다용도실의 한쪽 벽면을 열어보면 통신사에서 설치한 모뎀이 보인다. 모뎀 뒤에 있는 큰 박스는 허브라는 장치로 여러 컴퓨터를 연결해 주는 장치이다. 각 방에 있는 LAN포트와 유무선 공유기는 통신사에서 설치한 모뎀으로 연결된다. 세대통신단자함이 벽을 통해 각 방에 LAN포트와 연결되어 있는 구조 덕분에 노트북을 방에 있는 LAN포트와 직접 연결하거나 공유기에 LAN선을 연결하거나 WIFI를 이용하여 인터넷을 이용할 수 있다. 그럼 통신사에서 세대통신단자함에 설치한 모뎀은 어디로 연결될까? 벽면에 있는 세대통신단자함은 각 층 복도에 있는 중간배선반(IDF)에 연결된다. 중간배선반은 보안의 이유로 외부인이 접근할 수 없다. 제가 사는 아파트에는 통신실 내부에 중간배선반이 존재하는데 이 중간배선반이 각 층에 있는 것이 아니라 1개의 중간배선반이 3개의 층을 관리한다고 한다. 이제 중간배선반은 주배선반(MDF)에 연결된다. 주배선반은 아파트의 모든 케이블이 모여있다. 이제 이 주배선반은 ISP, 즉 통신사들과 연결된다. ISP는 Internet Service Provider의 약자로 우리가 흔히 통신사라고 부르는 곳이다. 우리나라에는 KT, SK, LG U+ 등이 있다. ISP들은 속도가 아주 빠른 광 케이블을 이용해 네트워크를 만든다. 이 부분을 백본 혹은 코어라고 부른다. 한국에 있는 ISP는 2티어 ISP로 분류된다. 1티어 ISP는 미국의 아주 큰 통신사들을 말한다. 한국의 2티어 ISP는 미국의 1티어 ISP에게 일정 금액을 지불하고 연결을 한다. 연결은 바닷속으로 광 케이블을 설치해서 하는데 굉장히 비용이 많이 든다. 미국의 ISP에는 미국에 거주하고 있는 사람들이 연결되어 서로 통신할 수 있게 한다. 그중에 구글도 있을 것이다. 한국 ISP를 통해 미국의 ISP로 전달된 데이터는 미국의 ISP와 연결된 구글의 웹 서버에 요청 데이터를 전달한다. 그럼 구글의 웹 서버는 웹 페이지를 보내달라는 요청에 응답해 웹 페이지 데이터를 저의 컴퓨터로 전송한다.

우리는 단순히 웹 브라우저에 텍스트를 입력하는 작은 일을 했지만 현실에서는 매우 먼 거리와 하드웨어를 거치는 거대한 일이다. 지금은 아주 간단하게 설명했지만 이렇게 데이터가 이동하는 과정에서 수많은 프로토콜을 이용한다. 우리가 이 네트워크에서 알아볼 것은 "어떤 프로토콜이 존재하고 그 프로토콜이 어떻게 조합해서 데이터 전송이 이루어지는가"이다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 네트워크 토폴로지

네트워크를 구성하는 장비와 ISP가 어떻게 연결되느냐에 따라서 형태는 다양할 것이다. 네트워크의 다양한 형태를 "토폴로지"라고 말한다. 이런 토폴로지는 크게 5가지로 나눌 수 있는데 하나씩 살펴보자.

### 버스 토폴로지

버스 토폴로지는 하나의 중앙 통신 회선에 여러 대의 노드를 연결하는 형태이다. 여기서 노드란 네트워크에 연결된 장비를 말한다. 우리의 컴퓨터, 허브, 라우터(공유기)등을 말한다. 버스 토폴로지의 장점은 새로운 노드의 추가, 제거가 간단하고 특정 노드에 장애가 발생하더라도 다른 노드에 영향을 끼치지 않는다. 반대로 단점은 중앙 통신 회선을 공유하기 때문에 트래픽이 증가하면 충돌이 발생해 성능이 떨어진다.

### 스타 토폴로지

스타 토폴로지는 중앙 노드를 중심으로 다른 모든 노드가 연결되는 형태이다. 스타 토폴로지의 장점은 문제가 생겼을 때 발견이 쉽고 관리도 편한 것이다. 만약 노드가 동작하지 않는다면 주 노드가 고장 났다고 추측할 수 도 있고 반대로 하나의 노드가 동작하지 않는다면 해당 노드가 고장 났다고 추측할 수 있다. 스타 토폴로지의 단점은 주 노드에 문제가 발생했을 때 전체 네트워크가 다운된다는 것이다.

### 링 토폴로지

링 토폴로지는 좌우 인접한 노드와 연결되어 원형을 이루는 형태이다. 하나의 노드에 다른 하나의 노드로만 데이터를 전송할 수 있으므로 충돌할 위험이 거의 없다는 장점이 있다. (여러 노드와 선을 공유하지 않아서 충돌이 발생하지 않음) 단점으로는 하나의 노드에 문제가 발생하면 전체 네트워크에 문제가 생길 수 있다는 것과 노드를 제거하거나 새로운 노드를 추가하기 힘들다는 것이다. (노드를 제거하려면 선을 제거하고 연결이 끊긴 노드는 다시 연결 필요)

### 트리 토폴로지

트리 토폴로지는 트리 자료구조 형태이다. 하나의 노드에 여러 노드가 트리구조로 연결되어 있다. 트리 토폴로지의 장점으로는 노드를 제거하거나 새로운 노드를 추가하는 것이 쉽고 자식-부모관계를 맺기 때문에 네트워크 장애를 해결하는 것도 어렵지 않다. 단점은 스타 토폴로지와 마찬가지로 루트 노드에 문제가 생기면 전체 네트워크가 다운될 수 있고 특정 노드에 트래픽이 집중되면 네트워크 속도가 떨어질 수 있다는 점이다.

### 매쉬 토폴로지

매쉬 토폴로지는 모든 노드가 직접 연결되어 있다는 점이다. 이 토폴로지의 장점은 특정 노드에 문제가 발생하더라도 전체 네트워크엔 이상이 없다는 점이다. 단점으로는 모든 노드를 연결해야 하므로 케이블이 많이 필요하고 비용이 많이 든다는 점이다. 매시 토폴로지로 이 세상 모든 노드를 연결한다면 아주 빠르고 안정적인 네트워크를 만들 수 있겠지만 이 세상 모든 노드를 연결한다는 것은 현실적으로 불가능하다. 따라서 용도와 비용을 계산해서 적절한 토폴로지를 혼합하여 사용해야 한다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트

이전 포스트엔 네트워크의 연결방식인 토폴로지를 알아봤다. 이번 포스트엔 네트워크의 통신 방식을 알아보겠다. 통신방식은 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트로 총 4가지로 나뉜다.

### 유니캐스트

근거리 네트워크가 구성되어 있다고 가정하자. 유니캐스트는 노드끼리 1:1 통신하는 방식이다. 노드들은 각자 고유한 주소를 가지고 있다. 그럼 데이터를 전송할 노드(출발지)가 목적지 노드의 주소를 적어서 연결된 모든 노드로 데이터를 전송한다. 그리고 각 노드는 이 데이터의 목적지 주소가 자기 주소와 같은지 확인한다. 만약 자기 주소와 일치하면 데이터를 처리하고 그렇지 않다면 버린다. 주소를 확인하는 작업은 랜카드가 하므로 CPU에 부담을 주지 않는 방식이다. 유니캐스트는 우리가 가장 많이 사용하는 통신방식이다.

### 브로드캐스트

브로드캐스트는 출발지에서 연결된 모든 노드에게 데이터를 전송하는 방식이다. 목적지는 모든 노드로 설정된다. 그럼 모든 노드는 데이터를 수신하고 랜카드가 인터럽트를 발생시켜 CPU에게 이 데이터를 처리할지 말지를 결정한다. 따라서 CPU에 부하를 주게 된다. 이런 이유로 브로드캐스트가 많이 발생하는 네트워크라면 네트워크 구성을 변경해야 한다.

### 멀티캐스트

멀티캐스트는 1:N으로 데이터를 전송하는 방식이다. 유니캐스트와 브로드캐스트의 단점을 보완하는 방식이다. 네트워크에 10개의 노드가 연결되어 있다고 하자. 출발지에서 주소 2부터 주소 8까지 7개의 노드에게만 데이터를 보내려고 한다. 만약 유니캐스트를 이용한다면 먼저 목적지 주소를 주소 2로 설정하여 모든 노드로 데이터를 전송한다. 그럼 주소 2인 노드만 이 데이터를 받고 나머지 노드 8개는 버릴 것이다. 주소 3에게도 같은 방식으로 보낸다. 이렇게 목적지를 주소 4, 주소 5, 주소 6, 주소 7, 주소 8로 총 5번을 더 보내야 한다. 유니캐스트는 이렇게 데이터를 전송할 노드가 많아진다면 출발지에서 데이터를 여러 번 보내야 하고 모든 노드의 트래픽이 증가하는 문제가 발생한다. 브로드캐스트를 이용하면 어떨까? 브로드캐스트를 이용하면 출발지에서 모든 노드로 한 번의 전송만 발생한다. 7개의 노드는 필요한 데이터니까 정확히 받은 것이지만 나머지 2개의 노드는 필요하지도 않은 데이터였지만 데이터를 수신했고 CPU에서 필요하지 않다고 판단할 것이다. 주소 9와 주소 10은 억울하게 CPU를 사용해 컴퓨터의 성능이 떨어질 것이다. 이렇듯 일부 그룹에만 데이터를 전송할 때는 유니캐스트, 브로드캐스트에는 각각 단점이 존재한다. 멀티캐스트는 이 단점을 해결하는 방식이다. 데이터를 받고자 하는 그룹을 만들어 해당 그룹원에게만 데이터를 전송한다. 따라서 유니캐스트처럼 데이터를 여러 번 보낼 필요도 없고 브로드캐스트처럼 억울하게 CPU를 사용할 일이 없을 것이다. 하지만 멀티캐스트는 장비가 멀티캐스트를 지원해야만 쓸 수 있다는 단점이 있다.

### 애니캐스트

애니캐스트는 네트워크에 연결된 노드 중 가장 가까운 노드에만 전송하는 방식이다. 이 방식은 브로드캐스트의 문제를 해결하는 방식으로 IPv6에서 사용된다.

> 이 포스트는 [감자](https://www.inflearn.com/course/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC# '감자')님의 강의를 참조하여 작성하였습니다.

## 단방향, 반이중, 전이중 통신

이번 포스트엔 전송방식에 따른 통신의 종류를 알아보자.

### 단방향 통신

단방향 통신은 한 방향으로만 데이터를 보낼 수 있는 통신이다. 오직 송신 측에서 수신 측으로만 데이터를 보낸다. 단방향 통신은 TV나 라디오등에서 사용한다. 이 통신 방식은 송신 측이 수신 측으로부터 어떠한 데이터를 받지 않기 때문에 수신 측에서 문제가 발생해도 송신 측은 알 수 없다는 단점이 있다.

### 반이중 통신

반이중 통신은 송신을 하는 동안에 수신을 할 수 없고 수신을 하는 동안에 송신을 할 수 없는 통신이다. 무전기가 대표적인 예시이다. 한 노드에서 데이터 전송을 하고 송신을 종료하는 신호를 보내면 그제야 수신측은 송신을 할 수 있다.

### 전이중 통신

전이중 통신은 송신과 수신을 동시에 할 수 있는 통신이다. 전화기가 대표적이다.
